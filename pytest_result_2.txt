============================= test session starts =============================
platform win32 -- Python 3.9.10, pytest-6.2.4, py-1.11.0, pluggy-0.13.1 -- C:\Dev\api_final_yatube\venv\Scripts\python.exe
django: settings: yatube_api.settings (from ini)
rootdir: C:\Dev\api_final_yatube, configfile: pytest.ini, testpaths: tests/
plugins: django-4.4.0, pythonpath-0.7.3
collecting ... collected 55 items

tests/test_comment.py::TestCommentAPI::test_comments_not_authenticated PASSED [  1%]
tests/test_comment.py::TestCommentAPI::test_comment_single_not_authenticated PASSED [  3%]
tests/test_comment.py::TestCommentAPI::test_comments_not_found PASSED    [  5%]
tests/test_comment.py::TestCommentAPI::test_comments_id_available PASSED [  7%]
tests/test_comment.py::TestCommentAPI::test_comments_get FAILED          [  9%]
tests/test_comment.py::TestCommentAPI::test_comment_create_by_unauth PASSED [ 10%]
tests/test_comment.py::TestCommentAPI::test_comments_post_auth_with_valid_data FAILED [ 12%]
tests/test_comment.py::TestCommentAPI::test_comments_auth_post_with_invalid_data PASSED [ 14%]
tests/test_comment.py::TestCommentAPI::test_comment_author_and_post_are_read_only FAILED [ 16%]
tests/test_comment.py::TestCommentAPI::test_comment_id_auth_get PASSED   [ 18%]
tests/test_comment.py::TestCommentAPI::test_comment_change_by_auth_with_valid_data[put] FAILED [ 20%]
tests/test_comment.py::TestCommentAPI::test_comment_change_by_auth_with_valid_data[patch] PASSED [ 21%]
tests/test_comment.py::TestCommentAPI::test_comment_change_not_auth_with_valid_data[put] PASSED [ 23%]
tests/test_comment.py::TestCommentAPI::test_comment_change_not_auth_with_valid_data[patch] PASSED [ 25%]
tests/test_comment.py::TestCommentAPI::test_comment_delete_by_author PASSED [ 27%]
tests/test_comment.py::TestCommentAPI::test_comment_delete_by_not_author PASSED [ 29%]
tests/test_comment.py::TestCommentAPI::test_comment_delete_by_unauth PASSED [ 30%]
tests/test_follow.py::TestFollowAPI::test_follow_not_found FAILED        [ 32%]
tests/test_follow.py::TestFollowAPI::test_follow_not_auth FAILED         [ 34%]
tests/test_follow.py::TestFollowAPI::test_follow_get FAILED              [ 36%]
tests/test_follow.py::TestFollowAPI::test_follow_create FAILED           [ 38%]
tests/test_follow.py::TestFollowAPI::test_follow_search_filter FAILED    [ 40%]
tests/test_group.py::TestGroupAPI::test_group_not_found PASSED           [ 41%]
tests/test_group.py::TestGroupAPI::test_group_list_not_auth PASSED       [ 43%]
tests/test_group.py::TestGroupAPI::test_group_page_not_found PASSED      [ 45%]
tests/test_group.py::TestGroupAPI::test_group_single_not_auth PASSED     [ 47%]
tests/test_group.py::TestGroupAPI::test_group_auth_get FAILED            [ 49%]
tests/test_group.py::TestGroupAPI::test_group_create PASSED              [ 50%]
tests/test_group.py::TestGroupAPI::test_group_page_auth_get PASSED       [ 52%]
tests/test_jwt.py::TestJWT::test_jwt_create__invalid_request_data PASSED [ 54%]
tests/test_jwt.py::TestJWT::test_jwt_create__valid_request_data PASSED   [ 56%]
tests/test_jwt.py::TestJWT::test_jwt_refresh__invalid_request_data PASSED [ 58%]
tests/test_jwt.py::TestJWT::test_jwt_refresh__valid_request_data PASSED  [ 60%]
tests/test_jwt.py::TestJWT::test_jwt_verify__invalid_request_data PASSED [ 61%]
tests/test_jwt.py::TestJWT::test_jwt_verify__valid_request_data PASSED   [ 63%]
tests/test_post.py::TestPostAPI::test_post_not_found PASSED              [ 65%]
tests/test_post.py::TestPostAPI::test_post_list_not_auth PASSED          [ 67%]
tests/test_post.py::TestPostAPI::test_post_single_not_auth PASSED        [ 69%]
tests/test_post.py::TestPostAPI::test_posts_auth_get FAILED              [ 70%]
tests/test_post.py::TestPostAPI::test_posts_get_paginated PASSED         [ 72%]
tests/test_post.py::TestPostAPI::test_post_create_auth_with_invalid_data PASSED [ 74%]
tests/test_post.py::TestPostAPI::test_post_create_auth_with_valid_data PASSED [ 76%]
tests/test_post.py::TestPostAPI::test_post_unauth_create PASSED          [ 78%]
tests/test_post.py::TestPostAPI::test_post_get_current PASSED            [ 80%]
tests/test_post.py::TestPostAPI::test_post_change_auth_with_valid_data[put] PASSED [ 81%]
tests/test_post.py::TestPostAPI::test_post_change_auth_with_valid_data[patch] PASSED [ 83%]
tests/test_post.py::TestPostAPI::test_post_change_not_auth_with_valid_data[put] PASSED [ 85%]
tests/test_post.py::TestPostAPI::test_post_change_not_auth_with_valid_data[patch] PASSED [ 87%]
tests/test_post.py::TestPostAPI::test_post_change_not_author_with_valid_data[put] PASSED [ 89%]
tests/test_post.py::TestPostAPI::test_post_change_not_author_with_valid_data[patch] PASSED [ 90%]
tests/test_post.py::TestPostAPI::test_post_patch_auth_with_invalid_data[put] PASSED [ 92%]
tests/test_post.py::TestPostAPI::test_post_patch_auth_with_invalid_data[patch] PASSED [ 94%]
tests/test_post.py::TestPostAPI::test_post_delete_by_author PASSED       [ 96%]
tests/test_post.py::TestPostAPI::test_post_delete_not_author PASSED      [ 98%]
tests/test_post.py::TestPostAPI::test_post_unauth_delete_current PASSED  [100%]

================================== FAILURES ===================================
______________________ TestCommentAPI.test_comments_get _______________________

self = <tests.test_comment.TestCommentAPI object at 0x000001879A3CBF40>
user_client = <rest_framework.test.APIClient object at 0x000001879A3DEEB0>
post = <Post: Тестовый пост 1>, comment_1_post = <Comment: Comment object (3)>
comment_2_post = <Comment: Comment object (4)>
comment_1_another_post = <Comment: Comment object (5)>

    def test_comments_get(self, user_client, post, comment_1_post,
                          comment_2_post, comment_1_another_post):
        response = user_client.get(
            self.comments_url.format(post_id=post.id)
        )
        assert response.status_code == HTTPStatus.OK, (
            'Проверьте, что при GET-запросе авторизованного пользователя к '
            f'`{self.comments_url}` возвращается ответ со статусом 200.'
        )
        test_data = response.json()
>       assert isinstance(test_data, list), (
            'Проверьте, что при GET-запросе авторизованного пользователя к '
            f'`{self.comments_url}` данные возвращаются в виде списка.'
        )
E       AssertionError: Проверьте, что при GET-запросе авторизованного пользователя к `/api/v1/posts/{post_id}/comments/` данные возвращаются в виде списка.
E       assert False
E        +  where False = isinstance({'count': 2, 'next': None, 'previous': None, 'results': [{'author': 'TestUser', 'created': '2023-11-11T21:53:24.314544... 3, 'post': 5, ...}, {'author': 'TestUserAnother', 'created': '2023-11-11T21:53:24.485159Z', 'id': 4, 'post': 5, ...}]}, list)

tests\test_comment.py:93: AssertionError
___________ TestCommentAPI.test_comments_post_auth_with_valid_data ____________

self = <tests.test_comment.TestCommentAPI object at 0x000001879A3C1DC0>
user_client = <rest_framework.test.APIClient object at 0x000001879A3CB640>
post = <Post: Тестовый пост 1>, user = <User: TestUser>
another_user = <User: TestUserAnother>

    def test_comments_post_auth_with_valid_data(self, user_client, post,
                                                user, another_user):
        comments_count = Comment.objects.count()
    
        assert_msg = (
            'Проверьте, что POST-запрос с корректными данными от '
            f'авторизованного пользователя к `{self.comments_url}` возвращает '
            'ответ со статусом 201.'
        )
        data = {'text': self.TEXT_FOR_COMMENT}
        try:
            response = user_client.post(
                self.comments_url.format(post_id=post.id),
                data=data
            )
        except IntegrityError as error:
            raise AssertionError(
                assert_msg + (
                    f' В процессе выполнения запроса произошла ошибка: {error}'
                )
            )
>       assert response.status_code == HTTPStatus.CREATED, assert_msg
E       AssertionError: Проверьте, что POST-запрос с корректными данными от авторизованного пользователя к `/api/v1/posts/{post_id}/comments/` возвращает ответ со статусом 201.
E       assert 400 == <HTTPStatus.CREATED: 201>
E         +400
E         -<HTTPStatus.CREATED: 201>

tests\test_comment.py:159: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Bad Request: /api/v1/posts/8/comments/
__________ TestCommentAPI.test_comment_author_and_post_are_read_only __________

self = <tests.test_comment.TestCommentAPI object at 0x000001879A3CB100>
user_client = <rest_framework.test.APIClient object at 0x000001879A4B4D30>
post = <Post: Тестовый пост 1>

    def test_comment_author_and_post_are_read_only(self, user_client, post):
        response = user_client.post(
            self.comments_url.format(post_id=post.id),
            data={}
        )
        assert response.status_code == HTTPStatus.BAD_REQUEST, (
            'Проверьте, что POST-запрос с некорректными данными от '
            f'авторизованного пользователя к `{self.comments_url}` возвращает '
            'ответ со статусом 400.'
        )
        data = set(response.json())
>       assert not {'author', 'post'}.intersection(data), (
            f'Проверьте, что для эндпоинта `{self.comments_url}` для полей '
            '`author` и `post` установлен свойство "Только для чтения".'
        )
E       AssertionError: Проверьте, что для эндпоинта `/api/v1/posts/{post_id}/comments/` для полей `author` и `post` установлен свойство "Только для чтения".
E       assert not {'post'}
E        +  where {'post'} = <built-in method intersection of set object at 0x000001879A470040>({'post', 'text'})
E        +    where <built-in method intersection of set object at 0x000001879A470040> = {'author', 'post'}.intersection

tests\test_comment.py:215: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Bad Request: /api/v1/posts/10/comments/
_______ TestCommentAPI.test_comment_change_by_auth_with_valid_data[put] _______

self = <tests.test_comment.TestCommentAPI object at 0x000001879A4A6AF0>
user_client = <rest_framework.test.APIClient object at 0x000001879A499B50>
post = <Post: Тестовый пост 1>, comment_1_post = <Comment: Comment object (8)>
comment_2_post = <Comment: Comment object (9)>, http_method = 'PUT'

    @pytest.mark.parametrize('http_method', ('put', 'patch'))
    def test_comment_change_by_auth_with_valid_data(self,
                                                    user_client,
                                                    post,
                                                    comment_1_post,
                                                    comment_2_post,
                                                    http_method):
        request_func = getattr(user_client, http_method)
        response = request_func(
            self.comment_detail_url.format(
                post_id=post.id, comment_id=comment_1_post.id
            ),
            data={'text': self.TEXT_FOR_COMMENT}
        )
        http_method = http_method.upper()
>       assert response.status_code == HTTPStatus.OK, (
            f'Проверьте, что {http_method}-запрос, отправленный '
            'авторизованным пользователем на эндпоинт '
            f'`{self.comment_detail_url}` к собственному комментарию, '
            'возвращает ответ со статусом 200.'
        )
E       AssertionError: Проверьте, что PUT-запрос, отправленный авторизованным пользователем на эндпоинт `/api/v1/posts/{post_id}/comments/{comment_id}/` к собственному комментарию, возвращает ответ со статусом 200.
E       assert 400 == <HTTPStatus.OK: 200>
E         +400
E         -<HTTPStatus.OK: 200>

tests\test_comment.py:264: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Bad Request: /api/v1/posts/12/comments/8/
_____________________ TestFollowAPI.test_follow_not_found _____________________

self = <tests.test_follow.TestFollowAPI object at 0x000001879A4FF7F0>
user_client = <rest_framework.test.APIClient object at 0x000001879A51B2E0>
follow_1 = <Follow: Follow object (1)>, follow_2 = <Follow: Follow object (2)>

    def test_follow_not_found(self, user_client, follow_1, follow_2):
        response = user_client.get(self.url)
    
>       assert response.status_code != HTTPStatus.NOT_FOUND, (
            f'Эндпоинт `{self.url}` не найден, проверьте настройки в '
            '*urls.py*.'
        )
E       AssertionError: Эндпоинт `/api/v1/follow/` не найден, проверьте настройки в *urls.py*.
E       assert 404 != <HTTPStatus.NOT_FOUND: 404>
E        +  where 404 = <HttpResponseNotFound status_code=404, "text/html">.status_code
E        +  and   <HTTPStatus.NOT_FOUND: 404> = HTTPStatus.NOT_FOUND

tests\test_follow.py:17: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Not Found: /api/v1/follow/
_____________________ TestFollowAPI.test_follow_not_auth ______________________

self = <tests.test_follow.TestFollowAPI object at 0x000001879A51B700>
client = <django.test.client.Client object at 0x000001879A502C40>
follow_1 = <Follow: Follow object (3)>, follow_2 = <Follow: Follow object (4)>

    def test_follow_not_auth(self, client, follow_1, follow_2):
        assert_msg = (
            'Проверьте, что GET-запрос неавторизованного пользователя к '
            f'`{self.url}` возвращает ответ со статусом 401.'
        )
        try:
            response = client.get(self.url)
        except TypeError as error:
            raise AssertionError(
                assert_msg + (
                    f' В процессе выполнения запроса произошла ошибка: {error}'
                )
            )
>       assert response.status_code == HTTPStatus.UNAUTHORIZED, assert_msg
E       AssertionError: Проверьте, что GET-запрос неавторизованного пользователя к `/api/v1/follow/` возвращает ответ со статусом 401.
E       assert 404 == <HTTPStatus.UNAUTHORIZED: 401>
E         +404
E         -<HTTPStatus.UNAUTHORIZED: 401>

tests\test_follow.py:35: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Not Found: /api/v1/follow/
________________________ TestFollowAPI.test_follow_get ________________________

self = <tests.test_follow.TestFollowAPI object at 0x000001879A4EEF70>
user_client = <rest_framework.test.APIClient object at 0x000001879A54FCD0>
user = <User: TestUser>, follow_1 = <Follow: Follow object (5)>
follow_2 = <Follow: Follow object (6)>, follow_3 = <Follow: Follow object (7)>

    def test_follow_get(self, user_client, user, follow_1, follow_2, follow_3):
        response = user_client.get(self.url)
>       assert response.status_code == HTTPStatus.OK, (
            'Проверьте, что GET-запрос авторизованного пользователя к '
            f'`{self.url}` возвращает ответ со статусом 200.'
        )
E       AssertionError: Проверьте, что GET-запрос авторизованного пользователя к `/api/v1/follow/` возвращает ответ со статусом 200.
E       assert 404 == <HTTPStatus.OK: 200>
E         +404
E         -<HTTPStatus.OK: 200>

tests\test_follow.py:46: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Not Found: /api/v1/follow/
______________________ TestFollowAPI.test_follow_create _______________________

self = <tests.test_follow.TestFollowAPI object at 0x000001879A4BBC10>
user_client = <rest_framework.test.APIClient object at 0x000001879A503DF0>
follow_2 = <Follow: Follow object (8)>, follow_3 = <Follow: Follow object (9)>
user = <User: TestUser>, user_2 = <User: TestUser2>
another_user = <User: TestUserAnother>

    def test_follow_create(self, user_client, follow_2, follow_3, user,
                           user_2, another_user):
        follow_count = Follow.objects.count()
    
        data = {}
        response = user_client.post(self.url, data=data)
>       assert response.status_code == HTTPStatus.BAD_REQUEST, (
            'Проверьте, что POST-запрос с некорректными данными, '
            f'отправленный к `{self.url}`, возвращает ответ со статусом 400.'
        )
E       AssertionError: Проверьте, что POST-запрос с некорректными данными, отправленный к `/api/v1/follow/`, возвращает ответ со статусом 400.
E       assert 404 == <HTTPStatus.BAD_REQUEST: 400>
E         +404
E         -<HTTPStatus.BAD_REQUEST: 400>

tests\test_follow.py:94: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Not Found: /api/v1/follow/
___________________ TestFollowAPI.test_follow_search_filter ___________________

self = <tests.test_follow.TestFollowAPI object at 0x000001879A4E7100>
user_client = <rest_framework.test.APIClient object at 0x000001879A54FA60>
follow_1 = <Follow: Follow object (10)>, follow_2 = <Follow: Follow object (11)>
follow_3 = <Follow: Follow object (12)>, follow_4 = <Follow: Follow object (13)>
follow_5 = <Follow: Follow object (14)>, user = <User: TestUser>
user_2 = <User: TestUser2>, another_user = <User: TestUserAnother>

    @pytest.mark.django_db(transaction=True)
    def test_follow_search_filter(self, user_client, follow_1, follow_2,
                                  follow_3, follow_4, follow_5,
                                  user, user_2, another_user):
    
        user_follows = Follow.objects.filter(user=user)
    
        response = user_client.get(self.url)
>       assert response.status_code != HTTPStatus.NOT_FOUND, (
            f'Эндпоинт `{self.url}` не найден, проверьте настройки в '
            '*urls.py*.'
        )
E       AssertionError: Эндпоинт `/api/v1/follow/` не найден, проверьте настройки в *urls.py*.
E       assert 404 != <HTTPStatus.NOT_FOUND: 404>
E        +  where 404 = <HttpResponseNotFound status_code=404, "text/html">.status_code
E        +  and   <HTTPStatus.NOT_FOUND: 404> = HTTPStatus.NOT_FOUND

tests\test_follow.py:171: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Not Found: /api/v1/follow/
______________________ TestGroupAPI.test_group_auth_get _______________________

self = <tests.test_group.TestGroupAPI object at 0x000001879A475610>
user_client = <rest_framework.test.APIClient object at 0x000001879A4DDC40>
group_1 = <Group: Группа 1>, group_2 = <Group: Группа 2>

    def test_group_auth_get(self, user_client, group_1, group_2):
        response = user_client.get(self.group_url)
        assert response.status_code == HTTPStatus.OK, (
            'Проверьте, что для авторизованного пользователя GET-запрос к '
            f'{self.group_url}` возвращает ответ со статусом 200.'
        )
    
        test_data = response.json()
>       assert isinstance(test_data, list), (
            'Проверьте, что для авторизованного пользователя '
            f'GET-запрос к `{self.group_url}` возвращает информацию о группах '
            'в виде списка.'
        )
E       AssertionError: Проверьте, что для авторизованного пользователя GET-запрос к `/api/v1/groups/` возвращает информацию о группах в виде списка.
E       assert False
E        +  where False = isinstance({'count': 2, 'next': None, 'previous': None, 'results': [{'description': '', 'id': 23, 'slug': 'group_1', 'title': 'Группа 1'}, {'description': '', 'id': 24, 'slug': 'group_2', 'title': 'Группа 2'}]}, list)

tests\test_group.py:77: AssertionError
_______________________ TestPostAPI.test_posts_auth_get _______________________

self = <tests.test_post.TestPostAPI object at 0x000001879A601FD0>
user_client = <rest_framework.test.APIClient object at 0x000001879A5A25B0>
post = <Post: Тестовый пост 1>, another_post = <Post: Тестовый пост 2>

    def test_posts_auth_get(self, user_client, post, another_post):
        response = user_client.get(self.post_list_url)
        assert response.status_code == HTTPStatus.OK, (
            'Проверьте, что GET-запрос авторизованного пользователя к '
            f'`{self.post_list_url}` возвращает статус 200.'
        )
    
        test_data = response.json()
>       assert isinstance(test_data, list), (
            'Проверьте, что GET-запрос авторизованного пользователя к '
            f'`{self.post_list_url}` возвращает список.'
        )
E       AssertionError: Проверьте, что GET-запрос авторизованного пользователя к `/api/v1/posts/` возвращает список.
E       assert False
E        +  where False = isinstance({'count': 2, 'next': None, 'previous': None, 'results': [{'author': 'TestUser', 'group': 31, 'id': 23, 'image': None, ...}, {'author': 'TestUserAnother', 'group': 32, 'id': 24, 'image': None, ...}]}, list)

tests\test_post.py:69: AssertionError
=========================== short test summary info ===========================
FAILED tests/test_comment.py::TestCommentAPI::test_comments_get - AssertionEr...
FAILED tests/test_comment.py::TestCommentAPI::test_comments_post_auth_with_valid_data
FAILED tests/test_comment.py::TestCommentAPI::test_comment_author_and_post_are_read_only
FAILED tests/test_comment.py::TestCommentAPI::test_comment_change_by_auth_with_valid_data[put]
FAILED tests/test_follow.py::TestFollowAPI::test_follow_not_found - Assertion...
FAILED tests/test_follow.py::TestFollowAPI::test_follow_not_auth - AssertionE...
FAILED tests/test_follow.py::TestFollowAPI::test_follow_get - AssertionError:...
FAILED tests/test_follow.py::TestFollowAPI::test_follow_create - AssertionErr...
FAILED tests/test_follow.py::TestFollowAPI::test_follow_search_filter - Asser...
FAILED tests/test_group.py::TestGroupAPI::test_group_auth_get - AssertionErro...
FAILED tests/test_post.py::TestPostAPI::test_posts_auth_get - AssertionError:...
======================= 11 failed, 44 passed in 15.35s ========================
